---

**Introduction**

Ever wondered how Python does so many handy things—like printing text or finding the absolute value of a number? The magic lies in **functions**! If you’re just starting out, understanding how to use and make your own functions can unlock all sorts of possibilities. In this beginner’s guide, we’ll explore what functions are, how to get help when you’re stuck, and walk through creating your very own Python functions. By the end, you’ll feel more confident and ready to experiment. Let’s get started!

*(Want to dive deeper? This entire lesson is inspired by this great [Kaggle notebook](https://www.kaggle.com/code/colinmorris/functions-and-getting-help).)*

---

### What Are Functions, and Why Do We Need Them?

Think of a function as a little machine—a box that takes something in, does something with it, and gives you back a result. For example:

- **print()**: Takes information and shows it on the screen.
- **abs()**: Takes a number and returns its absolute value.

Functions help us:
- **Reuse code** so we don’t have to repeat ourselves
- **Organize complex tasks** into short, simple steps
- **Share our work** with others (including our future selves!)

---

### Getting Help with Python Functions

#### The Magic of `help()`

When you’re unsure what a function does, ask Python directly! The built-in **help()** function explains what other functions do.

**Example:**
```python
help(round)
```
Output:
```
Help on built-in function round in module builtins:

round(number, ndigits=None)
    Round a number to a given precision in decimal digits.
```

**A few things help() tells you:**
- What arguments the function uses (like “number” and optional “ndigits”)
- A short description of the function’s job
- Sometimes, what value it gives back

**Watch Out!**
Don’t accidentally ask for help on a function’s *output* (like `help(round(-2.01))`). Always use the function name: `help(round)`.

---

### Defining Your Own Functions

You’re not limited to Python’s built-ins. Here’s how you make your own:

```python
def least_difference(a, b, c):
    diff1 = abs(a - b)
    diff2 = abs(b - c)
    diff3 = abs(a - c)
    return min(diff1, diff2, diff3)
```
- **def**: Tells Python you’re making a function
- **Arguments**: The function’s input (like a, b, c)
- **return**: The value your function gives back

**Try it out:**
```python
print(least_difference(1, 10, 100)) # Output: 9
print(least_difference(1, 10, 10))  # Output: 0
print(least_difference(5, 6, 7))    # Output: 1
```

---

### Making Your Functions Easier to Understand: Docstrings

Want to leave instructions for yourself or others? Add a **docstring**—a bit of text in triple quotes just after your function’s header.

```python
def least_difference(a, b, c):
    """Return the smallest difference between any two numbers
    among a, b and c.
    
    >>> least_difference(1, 5, -5)
    4
    """
    diff1 = abs(a - b)
    diff2 = abs(b - c)
    diff3 = abs(a - c)
    return min(diff1, diff2, diff3)
```

When you call `help(least_difference)`, Python shows your docstring to make things clearer!

---

### What Happens If You Don't `return` Anything?

If your function doesn’t use the **return** keyword, Python gives back a special value called **None**. This is similar to “nothing” or “null” in other languages.

```python
def least_difference(a, b, c):
    """Return the smallest difference between any two numbers
    among a, b and c.
    """
    diff1 = abs(a - b)
    diff2 = abs(b - c)
    diff3 = abs(a - c)
    min(diff1, diff2, diff3)  # No return!

print(least_difference(1, 10, 100)) # Output: None
```
Some functions are meant only to create effects instead of returning a value—like `print()` or writing to a file.

---

### Default Arguments: Making Functions Flexible

What if you want your function to use a standard value if nobody provides one? You can set a **default argument**.

```python
def greet(who="Colin"):
    print("Hello,", who)

greet()                # Output: Hello, Colin
greet(who="Kaggle")    # Output: Hello, Kaggle
greet("world")         # Output: Hello, world
```
Default arguments make your function easier to use!

---

### Higher-Order Functions: Using Functions as Arguments

Here’s a cool twist: you can pass functions into other functions! This is called “higher-order functions.”

**Example:**
```python
def mult_by_five(x):
    return 5 * x

def call(fn, arg):
    """Call fn on arg"""
    return fn(arg)

def squared_call(fn, arg):
    """Call fn on the result of calling fn on arg"""
    return fn(fn(arg))

print(call(mult_by_five, 1))        # Output: 5
print(squared_call(mult_by_five, 1))# Output: 25
```
You’ll see this a lot with functions like **max**—which can use another function to decide how it picks the “largest” value.

---

### Conclusion

- Python functions make your code neat, reusable, and powerful.
- Use **help()** when you get stuck.
- Write **docstrings** to help yourself and others.
- Play with your own functions—you’ll learn more as you go!

For even more tips and examples, check out the full lesson on [Kaggle](https://www.kaggle.com/code/colinmorris/functions-and-getting-help).

---

### FAQ

**1. What’s the difference between a function and a method?**  
A function is a general block of code you can call anywhere. A method is a function that belongs to an object (like “.append()” for lists).

**2. Do all functions return a value?**  
No—if you don’t use `return`, the function gives back `None`.

**3. How do I get help for my own function?**  
Just write a docstring under the function header, then call `help(your_function_name)`!

---

### What’s Next?

**Try writing a simple function yourself!**  
Experiment with calling `help()` on built-in Python functions. Got questions or neat examples? Share them in the comments below!

---

**Source:**  
This article builds directly on ideas from [Kaggle: Functions and Getting Help](https://www.kaggle.com/code/colinmorris/functions-and-getting-help).