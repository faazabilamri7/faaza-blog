---
title: '---'
category: general
tags:
  - general
  - auto-post
description: "publishDate: 2025-10-09T00:00:00Z\ntitle: 'GitHub Actions Core Features: Understanding Workflows, Jobs, and Steps'\nexcerpt: 'Master the building bloc..."
pubDate: '2025-10-09T03:28:56.513Z'
draft: false
excerpt: "publishDate: 2025-10-09T00:00:00Z\ntitle: 'GitHub Actions Core Features: Understanding Workflows, Jobs, and Steps'\nexcerpt: 'Master the building bloc..."
---

publishDate: 2025-10-09T00:00:00Z
title: 'GitHub Actions Core Features: Understanding Workflows, Jobs, and Steps'
excerpt: 'Master the building blocks of GitHub Actions: Learn how workflows, jobs, and steps work together to automate your development process. Written for beginners with practical examples.'
image: '~/assets/images/default.png'
category: DevOps
tags:
  - github-actions
  - workflows
  - automation
  - tutorial
  - yaml
metadata:
  canonical: https://faaza.dev/github-actions-core-features
---

## From Zero to Your First Automation

So you know what GitHub Actions is and why it's awesome. Now comes the fun part: **actually using it!**

In this guide, we'll dive into the core building blocks of GitHub Actions. Think of this as learning the alphabet before writing sentences‚Äîonce you understand these fundamentals, you'll be able to create powerful automation workflows.

**What you'll learn:**

- The anatomy of a GitHub Actions workflow
- How to trigger workflows automatically or manually
- Understanding jobs and steps (and how they're different)
- Passing data between different parts of your workflow
- Working with secrets and environment variables

Don't worry if you've never written YAML before. I'll explain everything in plain English with lots of examples.

_[Source: Complete GitHub Actions Course - 24:20-24:34](https://www.youtube.com/watch?v=Xwpi0ITkL3U&t=1460s)_

## Understanding the Key Concepts

Before we jump into code, let's understand the terminology. GitHub Actions has five key concepts that work together:

### 1. **Events** - The Trigger

Think of events as the "when" of your automation. These are things that happen in GitHub that can kick off your workflow:

- üìù Someone pushes code to a branch
- üîÄ Someone creates a pull request
- ‚è∞ A scheduled time arrives (like every night at midnight)
- üëÜ You manually click a button

**Real-world analogy:** Events are like motion sensors that detect activity and turn on the lights.

### 2. **Workflows** - The Automation Plan

A workflow is your complete automation recipe. It's defined in a YAML file and describes what should happen when an event occurs.

**Real-world analogy:** If events are the motion sensor, the workflow is the complete security system plan‚Äîwhat lights turn on, which cameras activate, and whether to send an alert.

### 3. **Jobs** - Parallel or Sequential Tasks

Jobs are major chunks of work within your workflow. They can run in parallel (at the same time) or sequentially (one after another).

**Real-world analogy:** If you're making breakfast, you might have three jobs: cook eggs, make toast, and brew coffee. These can all happen at the same time (parallel).

### 4. **Steps** - Individual Actions

Steps are the individual commands or actions within a job. They run one after another, in order.

**Real-world analogy:** For the "cook eggs" job, your steps might be: 1) crack eggs, 2) heat pan, 3) cook eggs, 4) plate eggs.

### 5. **Runners** - The Computers Doing the Work

Runners are the actual servers (virtual machines) that execute your jobs. They're the computers running your commands.

**Real-world analogy:** Runners are like the kitchen where your cooking jobs actually happen.

_[Source: Complete GitHub Actions Course - 24:34-25:31](https://www.youtube.com/watch?v=Xwpi0ITkL3U&t=1474s)_

## Your First "Hello World" Workflow

Let's start with the simplest possible workflow‚Äîa "Hello World" that prints a message.

### The Code

```yaml
name: Hello World Workflow

on:
  workflow_dispatch:

jobs:
  say-hello:
    runs-on: ubuntu-24.04
    steps:
      - name: Print greeting
        run: echo "Hello from an inline bash script in a GitHub action workflow"
```

### Breaking It Down

Let's understand each line:

**Line 1: `name: Hello World Workflow`**

- This is just a friendly name for your workflow
- You'll see this name in the GitHub Actions UI

**Line 3: `on: workflow_dispatch:`**

- This is our **event trigger**
- `workflow_dispatch` means "manual trigger"‚Äîyou can click a button to run it
- Perfect for testing!

**Line 5: `jobs:`**

- This starts the jobs section
- Everything indented under this is a job

**Line 6: `say-hello:`**

- This is the name/ID of our job
- You can name it anything (use lowercase and hyphens)

**Line 7: `runs-on: ubuntu-24.04`**

- Specifies which **runner** to use
- `ubuntu-24.04` means a Linux virtual machine with Ubuntu 24.04
- GitHub provides this for free!

**Line 8: `steps:`**

- Starts the list of steps for this job

**Line 9-10: Our actual step**

- `name:` - A description of what this step does
- `run:` - The bash command to execute
- `echo` prints text to the console

_[Source: Complete GitHub Actions Course - 25:31-26:26](https://www.youtube.com/watch?v=Xwpi0ITkL3U&t=1531s)_

### Running Your First Workflow

Here's how to actually run this:

1. **Create the file structure:**
   - In your repo, create: `.github/workflows/hello-world.yml`
   - The path matters! It must be in that exact location

2. **Paste the code above** into that file

3. **Commit and push** to GitHub

4. **Go to your repo on GitHub:**
   - Click the "Actions" tab
   - Find "Hello World Workflow" in the list
   - Click "Run workflow" button
   - Select the branch (probably `main`)
   - Click the green "Run workflow" button

5. **Watch it run:**
   - Refresh the page
   - Click on the workflow run
   - Click on the `say-hello` job
   - See your message printed!

_[Source: Complete GitHub Actions Course - 26:46-27:45](https://www.youtube.com/watch?v=Xwpi0ITkL3U&t=1606s)_

## Three Types of Steps You Can Use

Now that you've run a basic workflow, let's explore the three main types of steps you can use:

### Type 1: Inline Bash Scripts (What We Just Did)

```yaml
- name: Run bash command
  run: echo "This runs in bash!"
```

**Best for:** Simple commands, quick tasks

### Type 2: Different Shell Languages

You can run Python, PowerShell, or other languages:

```yaml
- name: Run Python script
  shell: python
  run: |
    print("Hello from Python!")
    x = 2 + 2
    print(f"2 + 2 = {x}")
```

**Notice the `|` symbol?** This lets you write multi-line scripts. Super handy!

**Best for:** When bash isn't the right tool, or you need Python's libraries

### Type 3: Pre-built Actions from the Marketplace

```yaml
- name: Use a third-party action
  uses: actions/hello-world-javascript-action@main
```

**The `uses:` keyword** tells GitHub to run someone else's action instead of your own code.

**Best for:** Common tasks that someone already solved (deploying to AWS, sending Slack messages, etc.)

_[Source: Complete GitHub Actions Course - 27:45-29:40](https://www.youtube.com/watch?v=Xwpi0ITkL3U&t=1665s)_

### Putting It All Together

Here's a workflow with all three types:

```yaml
name: Step Types Demo

on:
  workflow_dispatch:

jobs:
  bash-step:
    runs-on: ubuntu-24.04
    steps:
      - name: Bash example
        run: echo "Running from bash!"

  python-step:
    runs-on: ubuntu-24.04
    steps:
      - name: Python example
        shell: python
        run: print("Running from Python!")

  action-step:
    runs-on: ubuntu-24.04
    steps:
      - name: Third-party action example
        uses: actions/hello-world-javascript-action@main
```

**Notice:** We have three separate jobs here, so they'll all run **in parallel** (at the same time).

_[Source: Complete GitHub Actions Course - 28:03-29:18](https://www.youtube.com/watch?v=Xwpi0ITkL3U&t=1683s)_

## Controlling Job Order: Sequential Workflows

Sometimes you need jobs to run in a specific order. For example:

1. Build your code
2. Test your code
3. Deploy your code

You can't test before you build, and you shouldn't deploy before testing!

### The `needs` Keyword

Use `needs` to create dependencies between jobs:

```yaml
name: Sequential Jobs

on:
  workflow_dispatch:

jobs:
  job-1:
    runs-on: ubuntu-24.04
    steps:
      - run: echo "I run first!"

  job-2:
    runs-on: ubuntu-24.04
    steps:
      - run: echo "I also run first (parallel with job-1)!"

  job-3:
    runs-on: ubuntu-24.04
    needs: [job-1, job-2]
    steps:
      - run: echo "I wait for job-1 AND job-2 to finish!"

  job-4:
    runs-on: ubuntu-24.04
    needs: job-3
    steps:
      - run: echo "I run last, after job-3!"
```

### How This Runs:

```
job-1  \
        ‚ü∂  job-3  ‚ü∂  job-4
job-2  /
```

1. **First:** `job-1` and `job-2` run in parallel
2. **Then:** `job-3` waits for both to complete
3. **Finally:** `job-4` runs after `job-3`

This is called a **DAG** (Directed Acyclic Graph)‚Äîfancy words for "a flow chart that doesn't loop back on itself."

_[Source: Complete GitHub Actions Course - 29:58-31:07](https://www.youtube.com/watch?v=Xwpi0ITkL3U&t=1798s)_

## Triggering Workflows: When Should Things Run?

We've been using `workflow_dispatch` (manual trigger), but in real projects, you want automation! Let's explore the most common triggers:

### 1. **On Push to a Branch**

Run your workflow every time someone pushes code:

```yaml
on:
  push:
    branches:
      - main
      - 'feature/**' # Any branch starting with "feature/"
```

**Use case:** Run tests on every commit to your main branch

### 2. **On Pull Request**

Run when someone creates or updates a pull request:

```yaml
on:
  pull_request:
    branches:
      - main
    paths:
      - 'src/**' # Only trigger if files in 'src/' change
```

**Use case:** Automatically review code quality before merging

**Pro tip:** The `paths` filter is powerful! Use it to avoid running workflows when only documentation changes.

### 3. **On a Schedule**

Run your workflow at specific times using cron syntax:

```yaml
on:
  schedule:
    - cron: '0 0 * * *' # Every day at midnight UTC
```

**Common cron patterns:**

- `0 0 * * *` - Daily at midnight
- `0 */6 * * *` - Every 6 hours
- `0 0 * * 0` - Every Sunday at midnight
- `30 2 * * 1-5` - 2:30 AM, Monday through Friday

**Use case:** Nightly builds, weekly dependency updates, daily backups

### 4. **Manual Trigger (What We've Been Using)**

```yaml
on:
  workflow_dispatch:
```

**Use case:** Testing, running one-off tasks, or giving team members a button to click

### 5. **Combining Multiple Triggers**

You can use multiple triggers for the same workflow:

```yaml
on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
  schedule:
    - cron: '0 0 * * *'
  workflow_dispatch:
```

This workflow runs on:

- Pushes to main
- Pull requests to main
- Daily at midnight
- Manual trigger

_[Source: Complete GitHub Actions Course - 31:07-34:36](https://www.youtube.com/watch?v=Xwpi0ITkL3U&t=1867s)_

## Path Filters: Only Run When Relevant Files Change

Imagine you have a monorepo with a docs folder and a src folder. You don't want to run your expensive test suite when someone just fixes a typo in the docs!

### Using Path Filters

```yaml
name: Run Tests

on:
  pull_request:
    paths:
      - 'src/**/*.js' # Include all JS files in src/
      - 'package.json' # Include package.json
      - '!src/**/*.test.js' # Exclude test files
      - '!docs/**' # Exclude docs folder
```

### Filter Rules:

- **Include paths:** Just list them
- **Exclude paths:** Prefix with `!`
- **Use glob patterns:** `**` matches any directory depth, `*` matches any characters

**Real example from the course:**

```yaml
on:
  pull_request:
    paths:
      - '**.md' # Include markdown files
      - '!**.txt' # Exclude text files
```

If you modify only a `.txt` file, the workflow won't run. Modify a `.md` file, and it will!

_[Source: Complete GitHub Actions Course - 33:36-36:23](https://www.youtube.com/watch?v=Xwpi0ITkL3U&t=2016s)_

## Environment Variables: Storing Reusable Values

Environment variables let you store values that you can reuse throughout your workflow. You can set them at different levels:

### Workflow-Level Variables

Available in all jobs:

```yaml
name: Environment Variables Demo

env:
  WORKFLOW_VAR: "I'm available everywhere!"

jobs:
  job-1:
    runs-on: ubuntu-24.04
    steps:
      - run: echo $WORKFLOW_VAR # ‚úÖ This works!

  job-2:
    runs-on: ubuntu-24.04
    steps:
      - run: echo $WORKFLOW_VAR # ‚úÖ This also works!
```

### Job-Level Variables

Available only in that specific job:

```yaml
jobs:
  job-1:
    runs-on: ubuntu-24.04
    env:
      JOB_VAR: "I'm only in job-1!"
    steps:
      - run: echo $JOB_VAR # ‚úÖ Works here

  job-2:
    runs-on: ubuntu-24.04
    steps:
      - run: echo $JOB_VAR # ‚ùå Not defined here!
```

### Step-Level Variables

Available only in that single step:

```yaml
steps:
  - name: Step with its own variable
    env:
      STEP_VAR: "I'm only in this step!"
    run: echo $STEP_VAR # ‚úÖ Works

  - name: Another step
    run: echo $STEP_VAR # ‚ùå Not defined here!
```

**Think of it like Russian nesting dolls:** Inner dolls can see outer dolls, but outer dolls can't see inner dolls.

_[Source: Complete GitHub Actions Course - 36:41-37:49](https://www.youtube.com/watch?v=Xwpi0ITkL3U&t=2201s)_

## Passing Data Between Steps and Jobs

Sometimes you need to share data between different parts of your workflow. GitHub Actions provides special mechanisms for this:

### Within a Job: Step Outputs

To pass data from one step to another within the same job:

```yaml
jobs:
  data-passing:
    runs-on: ubuntu-24.04
    steps:
      # Step 1: Generate and save data
      - name: Generate data
        id: generator
        run: echo "my_value=Hello World" >> $GITHUB_OUTPUT

      # Step 2: Use that data
      - name: Use data
        run: echo "The value is: ${{ steps.generator.outputs.my_value }}"
```

**Breaking it down:**

1. Give the step an `id` (like "generator")
2. Write to `$GITHUB_OUTPUT` using the format `key=value`
3. Reference it later with `${{ steps.STEP_ID.outputs.KEY }}`

### Between Jobs: Job Outputs

To pass data from one job to another:

```yaml
jobs:
  producer:
    runs-on: ubuntu-24.04
    outputs:
      my_output: ${{ steps.gen.outputs.my_value }}
    steps:
      - name: Generate value
        id: gen
        run: echo "my_value=Important Data" >> $GITHUB_OUTPUT

  consumer:
    runs-on: ubuntu-24.04
    needs: producer
    steps:
      - name: Use value from producer
        run: echo "Got: ${{ needs.producer.outputs.my_output }}"
```

**The process:**

1. In the producer job, define an `outputs` section
2. Map job outputs to step outputs
3. In the consumer job, use `needs` to wait for the producer
4. Access with `${{ needs.JOB_NAME.outputs.OUTPUT_NAME }}`

**Important:** Environment variables do NOT persist between jobs. Only explicit outputs do!

_[Source: Complete GitHub Actions Course - 38:12-40:29](https://www.youtube.com/watch?v=Xwpi0ITkL3U&t=2292s)_

## Secrets and Variables: Keeping Sensitive Data Safe

You'll often need to store sensitive information like API keys, passwords, or tokens. GitHub provides two ways to store these:

### Secrets (For Sensitive Data) üîí

**Use for:** Passwords, API keys, tokens, certificates

```yaml
jobs:
  deploy:
    runs-on: ubuntu-24.04
    steps:
      - name: Deploy to production
        run: ./deploy.sh
        env:
          API_KEY: ${{ secrets.PROD_API_KEY }}
          DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
```

**Key features:**

- ‚úÖ Encrypted at rest
- ‚úÖ Never visible in logs (automatically masked with \*\*\*)
- ‚úÖ Can only be set, not read
- ‚úÖ Can be scoped to environments (staging vs production)

### Variables (For Non-Sensitive Data) üìã

**Use for:** Configuration values, feature flags, URLs

```yaml
jobs:
  build:
    runs-on: ubuntu-24.04
    steps:
      - name: Build app
        run: npm run build
        env:
          API_URL: ${{ vars.API_URL }}
          ENVIRONMENT: ${{ vars.ENVIRONMENT }}
```

**Key features:**

- ‚úÖ Visible in UI (can read and edit)
- ‚úÖ Not encrypted (don't use for sensitive data!)
- ‚úÖ Can be scoped to environments

### Setting Up Secrets and Variables

**In the GitHub UI:**

1. Go to your repository
2. Click **Settings**
3. Sidebar: **Secrets and variables** ‚Üí **Actions**
4. Choose either "Secrets" or "Variables" tab
5. Click "New repository secret/variable"
6. Add name and value

**For environment-specific values:**

1. Same path as above
2. Go to **Environments**
3. Create an environment (e.g., "production")
4. Add secrets/variables there

Then in your workflow:

```yaml
jobs:
  deploy-staging:
    runs-on: ubuntu-24.04
    environment: staging # Uses staging secrets/vars
    steps:
      - run: echo ${{ secrets.API_KEY }} # Staging API key

  deploy-production:
    runs-on: ubuntu-24.04
    environment: production # Uses production secrets/vars
    steps:
      - run: echo ${{ secrets.API_KEY }} # Production API key
```

_[Source: Complete GitHub Actions Course - 40:42-43:18](https://www.youtube.com/watch?v=Xwpi0ITkL3U&t=2442s)_

## Understanding Contexts: The Data Available to You

GitHub Actions provides tons of data about your workflow run through **contexts**. Think of contexts as pre-filled variables that GitHub gives you.

### Common Contexts You'll Use:

**`github` context** - Info about the repository and event:

```yaml
- run: echo "Branch: ${{ github.ref }}"
- run: echo "Commit SHA: ${{ github.sha }}"
- run: echo "Repository: ${{ github.repository }}"
- run: echo "Actor: ${{ github.actor }}"
```

**`env` context** - Environment variables:

```yaml
- run: echo "Path: ${{ env.PATH }}"
```

**`secrets` context** - Your secrets (already covered):

```yaml
- run: echo "API Key: ${{ secrets.API_KEY }}"
```

**`vars` context** - Your variables (already covered):

```yaml
- run: echo "Environment: ${{ vars.ENVIRONMENT }}"
```

**`steps` context** - Outputs from previous steps:

```yaml
- run: echo "Previous output: ${{ steps.previous.outputs.value }}"
```

**`needs` context** - Outputs from previous jobs:

```yaml
- run: echo "Job output: ${{ needs.build.outputs.version }}"
```

**`runner` context** - Info about the runner:

```yaml
- run: echo "OS: ${{ runner.os }}"
- run: echo "Temp directory: ${{ runner.temp }}"
```

**`job` context** - Info about the current job:

```yaml
- run: echo "Job status: ${{ job.status }}"
```

_[Source: Complete GitHub Actions Course - 43:36-44:09](https://www.youtube.com/watch?v=Xwpi0ITkL3U&t=2616s)_

## Key Takeaways

Let's recap what we've covered in this deep dive:

1. **Workflows are made of events, jobs, and steps** - Events trigger workflows, which contain jobs, which contain steps.

2. **Jobs run in parallel by default** - Use `needs` to create sequential workflows.

3. **You have three types of steps** - Bash scripts, other shells (like Python), or pre-built actions from the marketplace.

4. **Triggers can be flexible** - Use push events, pull requests, schedules, or manual dispatch based on your needs.

5. **Path filters prevent waste** - Don't run expensive tests when only docs change!

6. **Environment variables have scope** - Workflow, job, or step level‚Äîchoose based on where you need the data.

7. **Data passing requires explicit outputs** - Environment variables don't persist between jobs; use the output mechanism.

8. **Secrets keep sensitive data safe** - Always use secrets for passwords, tokens, and API keys.

9. **Contexts give you free data** - GitHub provides tons of useful information through contexts‚Äîuse them!

## Frequently Asked Questions

**Q: Can I run Windows or Mac jobs, or just Linux?**

A: GitHub provides runners for Linux, Windows, and macOS! Just change the `runs-on` value:

- `ubuntu-24.04` (Linux)
- `windows-latest` (Windows)
- `macos-latest` (macOS)

**Q: How many jobs can I run in parallel?**

A: On free plans, you can run up to 20 jobs concurrently on Linux, 5 on macOS, and 5 on Windows. Paid plans increase these limits.

**Q: What's the difference between `secrets` and `vars`?**

A: Secrets are encrypted and hidden (use for sensitive data). Variables are plaintext and visible (use for configuration). Both can be scoped to repositories or environments.

## Practice Exercise: Build Your Own Workflow

Ready to practice? Try creating a workflow that:

1. ‚úÖ Triggers on pull requests to the `main` branch
2. ‚úÖ Has two jobs: `lint` and `test`
3. ‚úÖ `test` should wait for `lint` to complete
4. ‚úÖ Use a repository variable to control which Node.js version to use
5. ‚úÖ Pass data from `lint` to `test` using outputs

**Bonus challenge:** Add path filters so it only runs when `.js` files change!

## What's Next?

You now have a solid foundation in GitHub Actions core features! In the next article, we'll explore advanced features like:

- Different types of runners (GitHub-hosted vs self-hosted vs third-party)
- Matrix builds (run the same tests across multiple versions)
- Reusable workflows
- Composite actions
- And much more!

**Ready to continue learning?** Check out the [complete free course on YouTube](https://www.youtube.com/watch?v=Xwpi0ITkL3U) that this series is based on.

Got stuck somewhere? **Drop a comment below** with your question, and I'll help you out!

---

_This article is based on the comprehensive GitHub Actions course by DevOps Directive. All timestamps reference the [original YouTube video](https://www.youtube.com/watch?v=Xwpi0ITkL3U)._