---
title: '---'
category: general
tags:
  - general
  - auto-post
description: "publishDate: 2025-10-09T00:00:00Z\ntitle: 'GitHub Actions Core Features: Understanding Workflows, Jobs, and Steps'\nexcerpt: 'Master the building bloc..."
pubDate: '2025-10-09T03:28:56.513Z'
draft: false
excerpt: "publishDate: 2025-10-09T00:00:00Z\ntitle: 'GitHub Actions Core Features: Understanding Workflows, Jobs, and Steps'\nexcerpt: 'Master the building bloc..."
---

publishDate: 2025-10-09T00:00:00Z
title: 'GitHub Actions Core Features: Understanding Workflows, Jobs, and Steps'
excerpt: 'Master the building blocks of GitHub Actions: Learn how workflows, jobs, and steps work together to automate your development process. Written for beginners with practical examples.'
image: '~/assets/images/default.png'
category: DevOps
tags:
  - github-actions
  - workflows
  - automation
  - tutorial
  - yaml
metadata:
  canonical: https://faaza.dev/github-actions-core-features
---

## From Zero to Your First Automation

So you know what GitHub Actions is and why it's awesome. Now comes the fun part: **actually using it!**

In this guide, we'll dive into the core building blocks of GitHub Actions. Think of this as learning the alphabet before writing sentencesâ€”once you understand these fundamentals, you'll be able to create powerful automation workflows.

**What you'll learn:**

- The anatomy of a GitHub Actions workflow
- How to trigger workflows automatically or manually
- Understanding jobs and steps (and how they're different)
- Passing data between different parts of your workflow
- Working with secrets and environment variables

Don't worry if you've never written YAML before. I'll explain everything in plain English with lots of examples.

_[Source: Complete GitHub Actions Course - 24:20-24:34](https://www.youtube.com/watch?v=Xwpi0ITkL3U&t=1460s)_

## Understanding the Key Concepts

Before we jump into code, let's understand the terminology. GitHub Actions has five key concepts that work together:

### 1. **Events** - The Trigger

Think of events as the "when" of your automation. These are things that happen in GitHub that can kick off your workflow:

- ðŸ“ Someone pushes code to a branch
- ðŸ”€ Someone creates a pull request
- â° A scheduled time arrives (like every night at midnight)
- ðŸ‘† You manually click a button

**Real-world analogy:** Events are like motion sensors that detect activity and turn on the lights.

### 2. **Workflows** - The Automation Plan

A workflow is your complete automation recipe. It's defined in a YAML file and describes what should happen when an event occurs.

**Real-world analogy:** If events are the motion sensor, the workflow is the complete security system planâ€”what lights turn on, which cameras activate, and whether to send an alert.

### 3. **Jobs** - Parallel or Sequential Tasks

Jobs are major chunks of work within your workflow. They can run in parallel (at the same time) or sequentially (one after another).

**Real-world analogy:** If you're making breakfast, you might have three jobs: cook eggs, make toast, and brew coffee. These can all happen at the same time (parallel).

### 4. **Steps** - Individual Actions

Steps are the individual commands or actions within a job. They run one after another, in order.

**Real-world analogy:** For the "cook eggs" job, your steps might be: 1) crack eggs, 2) heat pan, 3) cook eggs, 4) plate eggs.

### 5. **Runners** - The Computers Doing the Work

Runners are the actual servers (virtual machines) that execute your jobs. They're the computers running your commands.

**Real-world analogy:** Runners are like the kitchen where your cooking jobs actually happen.

_[Source: Complete GitHub Actions Course - 24:34-25:31](https://www.youtube.com/watch?v=Xwpi0ITkL3U&t=1474s)_

## Your First "Hello World" Workflow

Let's start with the simplest possible workflowâ€”a "Hello World" that prints a message.

### The Code

```yaml
name: Hello World Workflow

on:
  workflow_dispatch:

jobs:
  say-hello:
    runs-on: ubuntu-24.04
    steps:
      - name: Print greeting
        run: echo "Hello from an inline bash script in a GitHub action workflow"
```

### Breaking It Down

Let's understand each line:

**Line 1: `name: Hello World Workflow`**

- This is just a friendly name for your workflow
- You'll see this name in the GitHub Actions UI

**Line 3: `on: workflow_dispatch:`**

- This is our **event trigger**
- `workflow_dispatch` means "manual trigger"â€”you can click a button to run it
- Perfect for testing!

**Line 5: `jobs:`**

- This starts the jobs section
- Everything indented under this is a job

**Line 6: `say-hello:`**

- This is the name/ID of our job
- You can name it anything (use lowercase and hyphens)

**Line 7: `runs-on: ubuntu-24.04`**

- Specifies which **runner** to use
- `ubuntu-24.04` means a Linux virtual machine with Ubuntu 24.04
- GitHub provides this for free!

**Line 8: `steps:`**

- Starts the list of steps for this job

**Line 9-10: Our actual step**

- `name:` - A description of what this step does
- `run:` - The bash command to execute
- `echo` prints text to the console

_[Source: Complete GitHub Actions Course - 25:31-26:26](https://www.youtube.com/watch?v=Xwpi0ITkL3U&t=1531s)_

### Running Your First Workflow

Here's how to actually run this:

1. **Create the file structure:**
   - In your repo, create: `.github/workflows/hello-world.yml`
   - The path matters! It must be in that exact location

2. **Paste the code above** into that file

3. **Commit and push** to GitHub

4. **Go to your repo on GitHub:**
   - Click the "Actions" tab
   - Find "Hello World Workflow" in the list
   - Click "Run workflow" button
   - Select the branch (probably `main`)
   - Click the green "Run workflow" button

5. **Watch it run:**
   - Refresh the page
   - Click on the workflow run
   - Click on the `say-hello` job
   - See your message printed!

_[Source: Complete GitHub Actions Course - 26:46-27:45](https://www.youtube.com/watch?v=Xwpi0ITkL3U&t=1606s)_

## Three Types of Steps You Can Use

Now that you've run a basic workflow, let's explore the three main types of steps you can use:

### Type 1: Inline Bash Scripts (What We Just Did)

```yaml
- name: Run bash command
  run: echo "This runs in bash!"
```

**Best for:** Simple commands, quick tasks

### Type 2: Different Shell Languages

You can run Python, PowerShell, or other languages:

```yaml
- name: Run Python script
  shell: python
  run: |
    print("Hello from Python!")
    x = 2 + 2
    print(f"2 + 2 = {x}")
```

**Notice the `|` symbol?** This lets you write multi-line scripts. Super handy!

**Best for:** When bash isn't the right tool, or you need Python's libraries

### Type 3: Pre-built Actions from the Marketplace

```yaml
- name: Use a third-party action
  uses: actions/hello-world-javascript-action@main
```

**The `uses:` keyword** tells GitHub to run someone else's action instead of your own code.

**Best for:** Common tasks that someone already solved (deploying to AWS, sending Slack messages, etc.)

_[Source: Complete GitHub Actions Course - 27:45-29:40](https://www.youtube.com/watch?v=Xwpi0ITkL3U&t=1665s)_

### Putting It All Together

Here's a workflow with all three types:

```yaml
name: Step Types Demo

on:
  workflow_dispatch:

jobs:
  bash-step:
    runs-on: ubuntu-24.04
    steps:
      - name: Bash example
        run: echo "Running from bash!"

  python-step:
    runs-on: ubuntu-24.04
    steps:
      - name: Python example
        shell: python
        run: print("Running from Python!")

  action-step:
    runs-on: ubuntu-24.04
    steps:
      - name: Third-party action example
        uses: actions/hello-world-javascript-action@main
```

**Notice:** We have three separate jobs here, so they'll all run **in parallel** (at the same time).

_[Source: Complete GitHub Actions Course - 28:03-29:18](https://www.youtube.com/watch?v=Xwpi0ITkL3U&t=1683s)_

## Controlling Job Order: Sequential Workflows

Sometimes you need jobs to run in a specific order. For example:

1. Build your code
2. Test your code
3. Deploy your code

You can't test before you build, and you shouldn't deploy before testing!

### The `needs` Keyword

Use `needs` to create dependencies between jobs:

```yaml
name: Sequential Jobs

on:
  workflow_dispatch:

jobs:
  job-1:
    runs-on: ubuntu-24.04
    steps:
      - run: echo "I run first!"

  job-2:
    runs-on: ubuntu-24.04
    steps:
      - run: echo "I also run first (parallel with job-1)!"

  job-3:
    runs-on: ubuntu-24.04
    needs: [job-1, job-2]
    steps:
      - run: echo "I wait for job-1 AND job-2 to finish!"

  job-4:
    runs-on: ubuntu-24.04
    needs: job-3
    steps:
      - run: echo "I run last, after job-3!"
```

### How This Runs:

```
job-1  \
        âŸ¶  job-3  âŸ¶  job-4
job-2  /
```

1. **First:** `job-1` and `job-2` run in parallel
2. **Then:** `job-3` waits for both to complete
3. **Finally:** `job-4` runs after `job-3`

This is called a **DAG** (Directed Acyclic Graph)â€”fancy words for "a flow chart that doesn't loop back on itself."

_[Source: Complete GitHub Actions Course - 29:58-31:07](https://www.youtube.com/watch?v=Xwpi0ITkL3U&t=1798s)_

## Triggering Workflows: When Should Things Run?

We've been using `workflow_dispatch` (manual trigger), but in real projects, you want automation! Let's explore the most common triggers:

### 1. **On Push to a Branch**

Run your workflow every time someone pushes code:

```yaml
on:
  push:
    branches:
      - main
      - 'feature/**' # Any branch starting with "feature/"
```

**Use case:** Run tests on every commit to your main branch

### 2. **On Pull Request**

Run when someone creates or updates a pull request:

```yaml
on:
  pull_request:
    branches:
      - main
    paths:
      - 'src/**' # Only trigger if files in 'src/' change
```

**Use case:** Automatically review code quality before merging

**Pro tip:** The `paths` filter is powerful! Use it to avoid running workflows when only documentation changes.

### 3. **On a Schedule**

Run your workflow at specific times using cron syntax:

```yaml
on:
  schedule:
    - cron: '0 0 * * *' # Every day at midnight UTC
```

**Common cron patterns:**

- `0 0 * * *` - Daily at midnight
- `0 */6 * * *` - Every 6 hours
- `0 0 * * 0` - Every Sunday at midnight
- `30 2 * * 1-5` - 2:30 AM, Monday through Friday

**Use case:** Nightly builds, weekly dependency updates, daily backups

### 4. **Manual Trigger (What We've Been Using)**

```yaml
on:
  workflow_dispatch:
```

**Use case:** Testing, running one-off tasks, or giving team members a button to click

### 5. **Combining Multiple Triggers**

You can use multiple triggers for the same workflow:

```yaml
on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
  schedule:
    - cron: '0 0 * * *'
  workflow_dispatch:
```

This workflow runs on:

- Pushes to main
- Pull requests to main
- Daily at midnight
- Manual trigger

_[Source: Complete GitHub Actions Course - 31:07-34:36](https://www.youtube.com/watch?v=Xwpi0ITkL3U&t=1867s)_

## Path Filters: Only Run When Relevant Files Change

Imagine you have a monorepo with a docs folder and a src folder. You don't want to run your expensive test suite when someone just fixes a typo in the docs!

### Using Path Filters

```yaml
name: Run Tests

on:
  pull_request:
    paths:
      - 'src/**/*.js' # Include all JS files in src/
      - 'package.json' # Include package.json
      - '!src/**/*.test.js' # Exclude test files
      - '!docs/**' # Exclude docs folder
```

### Filter Rules:

- **Include paths:** Just list them
- **Exclude paths:** Prefix with `!`
- **Use glob patterns:** `**` matches any directory depth, `*` matches any characters

**Real example from the course:**

```yaml
on:
  pull_request:
    paths:
      - '**.md' # Include markdown files
      - '!**.txt' # Exclude text files
```

If you modify only a `.txt` file, the workflow won't run. Modify a `.md` file, and it will!

_[Source: Complete GitHub Actions Course - 33:36-36:23](https://www.youtube.com/watch?v=Xwpi0ITkL3U&t=2016s)_

## Environment Variables: Storing Reusable Values

Environment variables let you store values that you can reuse throughout your workflow. You can set them at different levels:

### Workflow-Level Variables

Available in all jobs:

```yaml
name: Environment Variables Demo

env:
  WORKFLOW_VAR: "I'm available everywhere!"

jobs:
  job-1:
    runs-on: ubuntu-24.04
    steps:
      - run: echo $WORKFLOW_VAR # âœ… This works!

  job-2:
    runs-on: ubuntu-24.04
    steps:
      - run: echo $WORKFLOW_VAR # âœ… This also works!
```

### Job-Level Variables

Available only in that specific job:

```yaml
jobs:
  job-1:
    runs-on: ubuntu-24.04
    env:
      JOB_VAR: "I'm only in job-1!"
    steps:
      - run: echo $JOB_VAR # âœ… Works here

  job-2:
    runs-on: ubuntu-24.04
    steps:
      - run: echo $JOB_VAR # âŒ Not defined here!
```

### Step-Level Variables

Available only in that single step:

```yaml
steps:
  - name: Step with its own variable
    env:
      STEP_VAR: "I'm only in this step!"
    run: echo $STEP_VAR # âœ… Works

  - name: Another step
    run: echo $STEP_VAR # âŒ Not defined here!
```

**Think of it like Russian nesting dolls:** Inner dolls can see outer dolls, but outer dolls can't see inner dolls.

_[Source: Complete GitHub Actions Course - 36:41-37:49](https://www.youtube.com/watch?v=Xwpi0ITkL3U&t=2201s)_

## Passing Data Between Steps and Jobs

Sometimes you need to share data between different parts of your workflow. GitHub Actions provides special mechanisms for this:

### Within a Job: Step Outputs

To pass data from one step to another within the same job:

```yaml
jobs:
  data-passing:
    runs-on: ubuntu-24.04
    steps:
      # Step 1: Generate and save data
      - name: Generate data
        id: generator
        run: echo "my_value=Hello World" >> $GITHUB_OUTPUT

      # Step 2: Use that data
      - name: Use data
        run: echo "The value is: ${{ steps.generator.outputs.my_value }}"
```

**Breaking it down:**

1. Give the step an `id` (like "generator")
2. Write to `$GITHUB_OUTPUT` using the format `key=value`
3. Reference it later with `${{ steps.STEP_ID.outputs.KEY }}`

### Between Jobs: Job Outputs

To pass data from one job to another:

```yaml
jobs:
  producer:
    runs-on: ubuntu-24.04
    outputs:
      my_output: ${{ steps.gen.outputs.my_value }}
    steps:
      - name: Generate value
        id: gen
        run: echo "my_value=Important Data" >> $GITHUB_OUTPUT

  consumer:
    runs-on: ubuntu-24.04
    needs: producer
    steps:
      - name: Use value from producer
        run: echo "Got: ${{ needs.producer.outputs.my_output }}"
```

**The process:**

1. In the producer job, define an `outputs` section
2. Map job outputs to step outputs
3. In the consumer job, use `needs` to wait for the producer
4. Access with `${{ needs.JOB_NAME.outputs.OUTPUT_NAME }}`

**Important:** Environment variables do NOT persist between jobs. Only explicit outputs do!

_[Source: Complete GitHub Actions Course - 38:12-40:29](https://www.youtube.com/watch?v=Xwpi0ITkL3U&t=2292s)_

## Secrets and Variables: Keeping Sensitive Data Safe

You'll often need to store sensitive information like API keys, passwords, or tokens. GitHub provides two ways to store these:

### Secrets (For Sensitive Data) ðŸ”’

**Use for:** Passwords, API keys, tokens, certificates

```yaml
jobs:
  deploy:
    runs-on: ubuntu-24.04
    steps:
      - name: Deploy to production
        run: ./deploy.sh
        env:
          API_KEY: ${{ secrets.PROD_API_KEY }}
          DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
```

**Key features:**

- âœ… Encrypted at rest
- âœ… Never visible in logs (automatically masked with \*\*\*)
- âœ… Can only be set, not read
- âœ… Can be scoped to environments (staging vs production)

### Variables (For Non-Sensitive Data) ðŸ“‹

**Use for:** Configuration values, feature flags, URLs

```yaml
jobs:
  build:
    runs-on: ubuntu-24.04
    steps:
      - name: Build app
        run: npm run build
        env:
          API_URL: ${{ vars.API_URL }}
          ENVIRONMENT: ${{ vars.ENVIRONMENT }}
```

**Key features:**

- âœ… Visible in UI (can read and edit)
- âœ… Not encrypted (don't use for sensitive data!)
- âœ… Can be scoped to environments

### Setting Up Secrets and Variables

**In the GitHub UI:**

1. Go to your repository
2. Click **Settings**
3. Sidebar: **Secrets and variables** â†’ **Actions**
4. Choose either "Secrets" or "Variables" tab
5. Click "New repository secret/variable"
6. Add name and value

**For environment-specific values:**

1. Same path as above
2. Go to **Environments**
3. Create an environment (e.g., "production")
4. Add secrets/variables there

Then in your workflow:

```yaml
jobs:
  deploy-staging:
    runs-on: ubuntu-24.04
    environment: staging # Uses staging secrets/vars
    steps:
      - run: echo ${{ secrets.API_KEY }} # Staging API key

  deploy-production:
    runs-on: ubuntu-24.04
    environment: production # Uses production secrets/vars
    steps:
      - run: echo ${{ secrets.API_KEY }} # Production API key
```

_[Source: Complete GitHub Actions Course - 40:42-43:18](https://www.youtube.com/watch?v=Xwpi0ITkL3U&t=2442s)_

## Understanding Contexts: The Data Available to You

GitHub Actions provides tons of data about your workflow run through **contexts**. Think of contexts as pre-filled variables that GitHub gives you.

### Common Contexts You'll Use:

**`github` context** - Info about the repository and event:

```yaml
- run: echo "Branch: ${{ github.ref }}"
- run: echo "Commit SHA: ${{ github.sha }}"
- run: echo "Repository: ${{ github.repository }}"
- run: echo "Actor: ${{ github.actor }}"
```

**`env` context** - Environment variables:

```yaml
- run: echo "Path: ${{ env.PATH }}"
```

**`secrets` context** - Your secrets (already covered):

```yaml
- run: echo "API Key: ${{ secrets.API_KEY }}"
```

**`vars` context** - Your variables (already covered):

```yaml
- run: echo "Environment: ${{ vars.ENVIRONMENT }}"
```

**`steps` context** - Outputs from previous steps:

```yaml
- run: echo "Previous output: ${{ steps.previous.outputs.value }}"
```

**`needs` context** - Outputs from previous jobs:

```yaml
- run: echo "Job output: ${{ needs.build.outputs.version }}"
```

**`runner` context** - Info about the runner:

```yaml
- run: echo "OS: ${{ runner.os }}"
- run: echo "Temp directory: ${{ runner.temp }}"
```

**`job` context** - Info about the current job:

```yaml
- run: echo "Job status: ${{ job.status }}"
```

_[Source: Complete GitHub Actions Course - 43:36-44:09](https://www.youtube.com/watch?v=Xwpi0ITkL3U&t=2616s)_

## Key Takeaways

Let's recap what we've covered in this deep dive:

1. **Workflows are made of events, jobs, and steps** - Events trigger workflows, which contain jobs, which contain steps.

2. **Jobs run in parallel by default** - Use `needs` to create sequential workflows.

3. **You have three types of steps** - Bash scripts, other shells (like Python), or pre-built actions from the marketplace.

4. **Triggers can be flexible** - Use push events, pull requests, schedules, or manual dispatch based on your needs.

5. **Path filters prevent waste** - Don't run expensive tests when only docs change!

6. **Environment variables have scope** - Workflow, job, or step levelâ€”choose based on where you need the data.

7. **Data passing requires explicit outputs** - Environment variables don't persist between jobs; use the output mechanism.

8. **Secrets keep sensitive data safe** - Always use secrets for passwords, tokens, and API keys.

9. **Contexts give you free data** - GitHub provides tons of useful information through contextsâ€”use them!

## Frequently Asked Questions

**Q: Can I run Windows or Mac jobs, or just Linux?**

A: GitHub provides runners for Linux, Windows, and macOS! Just change the `runs-on` value:

- `ubuntu-24.04` (Linux)
- `windows-latest` (Windows)
- `macos-latest` (macOS)

**Q: How many jobs can I run in parallel?**

A: On free plans, you can run up to 20 jobs concurrently on Linux, 5 on macOS, and 5 on Windows. Paid plans increase these limits.

**Q: What's the difference between `secrets` and `vars`?**

A: Secrets are encrypted and hidden (use for sensitive data). Variables are plaintext and visible (use for configuration). Both can be scoped to repositories or environments.

## Practice Exercise: Build Your Own Workflow

Ready to practice? Try creating a workflow that:

1. âœ… Triggers on pull requests to the `main` branch
2. âœ… Has two jobs: `lint` and `test`
3. âœ… `test` should wait for `lint` to complete
4. âœ… Use a repository variable to control which Node.js version to use
5. âœ… Pass data from `lint` to `test` using outputs

**Bonus challenge:** Add path filters so it only runs when `.js` files change!

## What's Next?

You now have a solid foundation in GitHub Actions core features! In the next article, we'll explore advanced features like:

- Different types of runners (GitHub-hosted vs self-hosted vs third-party)
- Matrix builds (run the same tests across multiple versions)
- Reusable workflows
- Composite actions
- And much more!

**Ready to continue learning?** Check out the [complete free course on YouTube](https://www.youtube.com/watch?v=Xwpi0ITkL3U) that this series is based on.

Got stuck somewhere? **Drop a comment below** with your question, and I'll help you out!

---

_This article is based on the comprehensive GitHub Actions course by DevOps Directive. All timestamps reference the [original YouTube video](https://www.youtube.com/watch?v=Xwpi0ITkL3U)._