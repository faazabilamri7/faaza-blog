---
title: '---'
category: general
tags:
  - general
  - auto-post
description: "title: 'Getting Started with Docker: Installation, Running Containers, and Managing Data'\ndescription: 'Learn how to install Docker Desktop, run your..."
pubDate: '2025-10-09T02:10:16.470Z'
draft: false
excerpt: "title: 'Getting Started with Docker: Installation, Running Containers, and Managing Data'\ndescription: 'Learn how to install Docker Desktop, run your..."
---

title: 'Getting Started with Docker: Installation, Running Containers, and Managing Data'
description: 'Learn how to install Docker Desktop, run your first containers, understand Docker volumes, and work with third-party images from Docker Hub. A practical, hands-on guide for beginners.'
publishDate: 2025-10-09
tags: ['docker', 'tutorial', 'installation', 'docker-volumes', 'beginner-guide']
draft: false
---

## Introduction

So you've learned what Docker is and why it's revolutionary for software development. Now comes the exciting part‚Äîactually using it!

In this hands-on guide, we'll walk through everything you need to get Docker up and running on your computer. You'll install Docker Desktop, run your first containers (including a fun ASCII art example and a real database), understand how to manage data in containers, and explore the treasure trove of pre-built images available on Docker Hub.

By the end of this tutorial, you'll have Docker installed on your system and the confidence to run and experiment with containers. Don't worry if you're completely new to this‚Äîwe'll explain everything step by step in plain language.

**Source:** [Complete Docker Course - From BEGINNER to PRO!](https://www.youtube.com/watch?v=RqTEHSBrYFw) (40:30 - 1:13:00)

## Installing Docker Desktop

### Understanding Docker Desktop vs. Docker Engine

Before we install anything, let's quickly clarify what we're installing:

**Docker Engine:**

- The core open-source components (CLI, daemon, API)
- Only runs on Linux
- Perfect for servers
- Free for everyone

**Docker Desktop:**

- Includes Docker Engine PLUS
- Nice graphical interface (GUI)
- Works on Windows and Mac (creates a Linux VM automatically)
- Easier developer experience
- Free for personal use and small businesses

**For this tutorial, we're installing Docker Desktop** because it's the easiest way to get started, especially on Windows or Mac.

### System Requirements and Licensing

**Important note about licensing:**

- ‚úÖ **Free:** Personal use, education, open-source projects
- ‚úÖ **Free:** Small companies (less than 250 employees AND less than $10M revenue)
- üí∞ **Paid:** Larger companies need a subscription

Check the [Docker pricing page](https://www.docker.com/pricing/) for the most current information.

### Installation Steps

#### For Windows Users

**Step 1:** Go to [docs.docker.com/get-docker](https://docs.docker.com/get-docker/)

**Step 2:** Click on "Docker Desktop for Windows"

**Step 3:** Download the installer (it's a large file, about 600MB)

**Step 4:** Run the installer

**Step 5:** **Important choice!** You'll be asked to choose a backend:

- **WSL 2 (Recommended):** Use Windows Subsystem for Linux
- **Hyper-V:** Alternative virtualization technology

**Which should you choose?** Go with **WSL 2** unless you have a specific reason not to. It's the modern, recommended approach that offers better performance and integration with Windows.

**Step 6:** Complete the installation and restart your computer if prompted

#### For Mac Users

**Step 1:** Go to [docs.docker.com/get-docker](https://docs.docker.com/get-docker/)

**Step 2:** Choose your Mac type:

- **Intel chip:** Docker Desktop for Mac (Intel)
- **Apple Silicon (M1/M2/M3):** Docker Desktop for Mac (Apple chip)

Not sure which you have? Click the Apple logo in the top-left corner, then "About This Mac."

**Step 3:** Download the `.dmg` file (around 600MB, expands to ~2GB)

**Step 4:** Open the downloaded file and drag Docker into your Applications folder

**Step 5:** Open Docker from Applications

**Step 6:** You may see a security warning‚Äîclick "Open" to trust the application

#### For Linux Users

Linux users can install Docker Engine directly without Docker Desktop. Follow the instructions for your specific distribution at [docs.docker.com/engine/install/](https://docs.docker.com/engine/install/)

### First-Time Setup: Configuring Resources

After installation, Docker Desktop will open with a welcome screen. Here's an important first step:

**Step 1:** Click on the gear icon (‚öôÔ∏è) to open Settings

**Step 2:** Go to "Resources"

**Step 3:** Configure how much of your computer Docker can use:

- **CPUs:** How many processor cores (default is usually 4)
- **Memory:** How much RAM (default is often 2-4GB)
- **Disk:** How much storage space

**My recommendations for beginners:**

- **CPUs:** 4 (or half of what your system has)
- **Memory:** 8GB if you have 16GB+ total RAM, 4GB if you have 8GB total
- **Disk:** At least 60GB if you have space

**Why this matters:** Docker containers run inside a Linux virtual machine on Windows/Mac. These settings determine the maximum resources that VM can use. If you run out of memory later, you can always come back and increase these values.

**Step 4:** Click "Apply & Restart" to save changes

### Verify Installation

Let's make sure everything is working! Open your terminal (Command Prompt, PowerShell, or Terminal on Mac):

```bash
docker --version
```

You should see something like:

```
Docker version 24.0.6, build ed223bc
```

If you see this, congratulations! Docker is installed correctly. üéâ

## Running Your First Container: The Whale Says Hello

Now for the fun part‚Äîlet's run our very first container!

### The Whalesay Example

Open your terminal and type this command:

```bash
docker run docker/whalesay cowsay "Hey team!"
```

Let's break down what each part means:

- `docker run` = "Docker, please run a container"
- `docker/whalesay` = The name of the container image to use
- `cowsay` = A command to run inside the container
- `"Hey team!"` = The message we want to display

**What happens when you press Enter:**

1. **Docker checks locally:** "Do I have the whalesay image?"
2. **If not, downloads it:** You'll see lines like "Pulling from docker/whalesay"
3. **Each line represents a layer:** Remember union file systems? Each download line is one layer
4. **Creates and runs the container:** Executes the cowsay command with your message
5. **Shows output:** You see ASCII art of a whale saying your message!
6. **Container exits:** After showing the message, the container stops

**Example output:**

```
 ___________
< Hey team! >
 -----------
    \
     \
      \
                    ##        .
              ## ## ##       ==
           ## ## ## ##      ===
       /""""""""""""""""___/ ===
  ~~~ {~~ ~~~~ ~~~ ~~~~ ~~ ~ /  ===- ~~~
       \______ o          __/
        \    \        __/
          \____\______/
```

**What just happened?** You just:

1. Downloaded a container image from Docker Hub
2. Created a container from that image
3. Ran a program inside an isolated environment
4. Got output from that program

All without installing anything except Docker itself!

### Understanding What Happened Behind the Scenes

When you ran that command, Docker:

1. **Checked your local image library:** "Do I have docker/whalesay?"
2. **Connected to Docker Hub:** The public registry of images
3. **Downloaded the image in layers:** More efficient than one big download
4. **Stored it locally:** Next time you run it, no download needed!
5. **Created an isolated environment:** Using namespaces and cgroups
6. **Ran your command:** Inside that isolated container
7. **Cleaned up:** The container stopped after the command finished

## Running a Real Application: PostgreSQL Database

The whalesay example was fun, but let's run something more practical‚Äîa real database server!

### Starting a PostgreSQL Database Container

Type this command (it's longer, but we'll explain every part):

```bash
docker run \
  --name my-postgres \
  -e POSTGRES_PASSWORD=mysecretpassword \
  -p 5432:5432 \
  postgres:15.1-alpine
```

**Breaking it down:**

- `docker run` = Run a container
- `--name my-postgres` = Give this container a friendly name (instead of a random ID)
- `-e POSTGRES_PASSWORD=mysecretpassword` = Set an environment variable (PostgreSQL requires a password)
- `-p 5432:5432` = **Port mapping** (more on this below!)
- `postgres:15.1-alpine` = The image name and specific version

### Understanding Port Mapping

This is crucial, so let's dig deeper.

**The problem:** Containers run in an isolated network. Without doing anything special, you can't connect to services running inside them.

**The solution:** Port mapping (also called port publishing)

The `-p 5432:5432` flag means:

- **Left side (5432):** Port on your computer (the host)
- **Right side (5432):** Port inside the container
- **The colon (:):** Connects them together

**Think of it like this:**
Imagine the container is a house on a private street. Port mapping is like creating a tunnel from your main street to their private street. When you knock on door 5432 on your street, it tunnels to door 5432 on their street.

**In practice:**

- Your application connects to `localhost:5432`
- Docker forwards that connection to port 5432 inside the container
- The PostgreSQL server inside the container receives the connection

**Note:** The ports don't have to match! You could do `-p 3000:5432` to access the container's port 5432 via your host's port 3000.

### Watching Your Container Run

After running that command, you'll see logs from PostgreSQL:

```
PostgreSQL init process complete; ready for start up.
LOG:  database system is ready to accept connections
```

Success! You now have a PostgreSQL database running in a container.

**To stop it:** Press `Ctrl+C` in the terminal

**To run it in the background:** Add the `-d` flag (detached mode):

```bash
docker run -d \
  --name my-postgres \
  -e POSTGRES_PASSWORD=mysecretpassword \
  -p 5432:5432 \
  postgres:15.1-alpine
```

Now it runs in the background, and you get your terminal back.

### Connecting to Your Database

You can connect to this database using any PostgreSQL client:

- **Host:** localhost (or 127.0.0.1)
- **Port:** 5432
- **Username:** postgres (default)
- **Password:** mysecretpassword (what we set)
- **Database:** postgres (default)

**Using a GUI tool like pgAdmin:**

1. Add a new server
2. Enter the connection details above
3. Connect!

You now have a fully functional database running in a container‚Äîno complex installation required!

## Understanding Docker Volumes: Solving the Data Persistence Problem

Here's a critical question: **What happens to your data when you stop and remove a container?**

**Short answer:** It's gone forever. üò±

**Why?** Remember from the first article‚Äîcontainers have a thin read-write layer on top of read-only image layers. When you delete a container, that read-write layer disappears.

This is a problem for databases and any application that creates important data. So how do we solve it?

### The Container File System: A Quick Refresher

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Read-Write Layer      ‚îÇ  ‚Üê Created at runtime, deleted with container
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   Image Layer 3         ‚îÇ  ‚Üê Read-only
‚îÇ   Image Layer 2         ‚îÇ  ‚Üê Read-only
‚îÇ   Image Layer 1         ‚îÇ  ‚Üê Read-only
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

Any data you create goes in that read-write layer. Remove the container = lose the data.

### Two Solutions: Volumes and Bind Mounts

Docker gives us two ways to persist data:

#### 1. Docker Volumes (Recommended)

**What they are:** Special storage areas managed by Docker

**Where data is stored:** Inside the Docker VM at `/var/lib/docker/volumes/`

**Best for:**

- Database files
- Application data that needs to persist
- Production environments

**Pros:**

- ‚úÖ Better performance (especially on Mac/Windows)
- ‚úÖ Docker manages them (easy to list, backup, etc.)
- ‚úÖ Can be shared between containers
- ‚úÖ Work the same on all operating systems

**Cons:**

- ‚ùå Harder to browse files directly (they're in the VM)

#### 2. Bind Mounts

**What they are:** Direct connections between your computer's file system and the container

**Where data is stored:** Wherever you specify on your computer

**Best for:**

- Development (mounting source code)
- Configuration files
- When you need easy access to files

**Pros:**

- ‚úÖ Easy to see and edit files on your computer
- ‚úÖ Changes appear immediately in the container
- ‚úÖ Great for development workflow

**Cons:**

- ‚ùå Slower performance (crossing the VM boundary)
- ‚ùå Path issues between different operating systems

### Hands-On: Experimenting with Container Data Persistence

Let's do an experiment to understand this better.

#### Experiment 1: Data Disappears

**Step 1:** Run an Ubuntu container with an interactive shell:

```bash
docker run -it --rm ubuntu:22.04 /bin/bash
```

**Flags explained:**

- `-it` = Interactive with a terminal (you get a command line inside)
- `--rm` = Remove this container when we exit
- `ubuntu:22.04` = Ubuntu Linux version 22.04 image
- `/bin/bash` = Run the bash shell

**Step 2:** Inside the container, try to ping Google:

```bash
ping google.com -c 1
```

**Result:** Command not found! Ping isn't installed in this minimal Ubuntu image.

**Step 3:** Install ping:

```bash
apt update
apt install iputils-ping -y
```

**Step 4:** Now ping works:

```bash
ping google.com -c 1
```

**Step 5:** Exit the container:

```bash
exit
```

**Step 6:** Run the exact same command again:

```bash
docker run -it --rm ubuntu:22.04 /bin/bash
```

**Step 7:** Try ping again:

```bash
ping google.com -c 1
```

**Result:** Command not found again!

**Why?** We installed ping in the read-write layer of the first container. When we exited, that container was removed (because of `--rm`), and all changes were lost. The new container started fresh from the base image.

#### Experiment 2: Persisting Data with a Volume

Now let's fix this by using a volume:

**Step 1:** Create a named volume:

```bash
docker volume create my-data
```

**Step 2:** Run a container with that volume mounted:

```bash
docker run -it --rm \
  --name my-container \
  -v my-data:/data \
  ubuntu:22.04 /bin/bash
```

**The `-v` flag:** `my-data:/data` means:

- `my-data` = The volume name
- `/data` = Where to mount it inside the container

**Step 3:** Inside the container, create a file in the volume:

```bash
echo "Hello from the container!" > /data/message.txt
cat /data/message.txt
```

**Step 4:** Exit the container:

```bash
exit
```

**Step 5:** Run a NEW container with the SAME volume:

```bash
docker run -it --rm \
  -v my-data:/data \
  ubuntu:22.04 /bin/bash
```

**Step 6:** Check if the file still exists:

```bash
cat /data/message.txt
```

**Result:** "Hello from the container!"

**Success!** The data persisted because it was stored in the volume, not in the container's read-write layer.

#### Experiment 3: Bind Mount for Development

Let's say you're developing a website. You want to edit HTML on your computer and see changes immediately.

**Step 1:** Create a simple HTML file on your computer:

```bash
mkdir ~/my-website
echo "<h1>Hello, Docker!</h1>" > ~/my-website/index.html
```

**Step 2:** Run an nginx web server with a bind mount:

```bash
docker run -d \
  --name my-web \
  -p 8080:80 \
  -v ~/my-website:/usr/share/nginx/html \
  nginx:alpine
```

**What's happening:**

- `-v ~/my-website:/usr/share/nginx/html` = Bind mount
- Your local folder `~/my-website` appears at `/usr/share/nginx/html` inside the container
- Nginx serves files from that location

**Step 3:** Open your browser and go to `http://localhost:8080`

You'll see: **Hello, Docker!**

**Step 4:** Edit the HTML file on your computer:

```bash
echo "<h1>Updated content!</h1>" > ~/my-website/index.html
```

**Step 5:** Refresh your browser

You'll immediately see: **Updated content!**

**Why this is powerful:** You're editing files on your computer with your favorite editor, but the web server inside the container serves them instantly. Perfect for development!

## Exploring Docker Hub: A Library of Pre-Built Images

One of Docker's superpowers is Docker Hub‚Äîa massive public library of container images.

### What is Docker Hub?

Think of Docker Hub like:

- **An app store for containers**
- **A library of pre-packaged software**
- **A sharing platform for the Docker community**

**Stats:**

- Over 100,000 public images
- Millions of downloads per day
- Both official and community images

### Finding Images on Docker Hub

**Go to:** [hub.docker.com](https://hub.docker.com)

**You can:**

1. **Search** by name (e.g., "postgres", "redis", "node")
2. **Browse** by category (Databases, Web Servers, Operating Systems, etc.)
3. **Filter** by:
   - Official Images (verified by Docker)
   - Verified Publisher (verified by the company)
   - Community images

### Understanding Image Tags

When you pull an image, you'll see tags like:

- `postgres:15.1`
- `postgres:15.1-alpine`
- `node:18`
- `node:18-slim`

**What are tags?** Different versions or variations of the same image.

**Common patterns:**

- **Version numbers:** `15.1`, `18.2`, `3.9` (specific versions)
- **latest:** The most recent version (use with caution in production!)
- **alpine:** Based on Alpine Linux (much smaller size)
- **slim:** Trimmed-down version (smaller than default, bigger than alpine)
- **bullseye, bookworm:** Specific Debian versions

**Example: Node.js image tags**

- `node:18` = Node.js 18, full Debian image (~900MB)
- `node:18-alpine` = Node.js 18, Alpine Linux (~170MB)
- `node:18-slim` = Node.js 18, minimal Debian (~200MB)

**Pro tip:** For learning, use specific version tags. For production, ALWAYS use specific versions (never `latest`).

### Popular Images to Explore

Here are some commonly used images great for beginners:

**Databases:**

- `postgres` - PostgreSQL database
- `mysql` - MySQL database
- `mongo` - MongoDB database
- `redis` - Redis cache

**Web Servers:**

- `nginx` - Nginx web server
- `httpd` - Apache HTTP server

**Programming Languages:**

- `node` - Node.js runtime
- `python` - Python runtime
- `golang` - Go programming language
- `openjdk` - Java runtime

**Utilities:**

- `alpine` - Minimal Linux OS (5MB!)
- `ubuntu` - Ubuntu Linux
- `busybox` - Tiny utilities image

### Reading an Image Page

When you click on an image on Docker Hub, you'll find:

1. **Description:** What the image is for
2. **How to use:** Example commands
3. **Tags:** Available versions
4. **Dockerfile:** How the image is built (advanced)
5. **Environment variables:** Configuration options
6. **Exposed ports:** Which ports the application uses

**Example: postgres image page**

- Shows you need to set `POSTGRES_PASSWORD`
- Explains default username is `postgres`
- Lists all available versions
- Gives examples of running with volumes

## Useful Docker Commands for Managing Containers

Now that you're running containers, here are essential commands:

### Listing Containers

**See running containers:**

```bash
docker ps
```

**See all containers (including stopped):**

```bash
docker ps -a
```

### Starting and Stopping

**Stop a running container:**

```bash
docker stop my-postgres
```

**Start a stopped container:**

```bash
docker start my-postgres
```

**Restart a container:**

```bash
docker restart my-postgres
```

### Removing Containers

**Remove a stopped container:**

```bash
docker rm my-postgres
```

**Force remove a running container:**

```bash
docker rm -f my-postgres
```

**Remove all stopped containers:**

```bash
docker container prune
```

### Working with Images

**List downloaded images:**

```bash
docker images
```

**Remove an image:**

```bash
docker rmi postgres:15.1-alpine
```

**Remove unused images:**

```bash
docker image prune
```

### Managing Volumes

**List volumes:**

```bash
docker volume ls
```

**Inspect a volume:**

```bash
docker volume inspect my-data
```

**Remove a volume:**

```bash
docker volume rm my-data
```

**Remove unused volumes:**

```bash
docker volume prune
```

### Getting Container Information

**View container logs:**

```bash
docker logs my-postgres
```

**Follow logs in real-time:**

```bash
docker logs -f my-postgres
```

**Execute a command in a running container:**

```bash
docker exec -it my-postgres /bin/bash
```

This last one is super useful for debugging‚Äîyou can "enter" a running container and poke around!

## Conclusion: You're Up and Running!

Congratulations! You've accomplished a lot in this tutorial:

‚úÖ Installed Docker Desktop on your system  
‚úÖ Configured resource allocation  
‚úÖ Ran your first containers  
‚úÖ Learned about port mapping  
‚úÖ Understood the data persistence problem  
‚úÖ Used volumes and bind mounts  
‚úÖ Explored Docker Hub  
‚úÖ Learned essential Docker commands

You now have the practical skills to run and manage containers on your system. But we've been using images created by other people. In the next article, we'll learn how to create our own custom container images for our applications!

## Frequently Asked Questions

**Q: My container keeps exiting immediately. Why?**

A: Containers run as long as their main process is running. When that process exits, so does the container. For example, if you run `docker run ubuntu`, it starts and immediately exits because there's no command to keep it running. Add a command like `docker run -it ubuntu /bin/bash` to keep it alive.

**Q: How do I free up disk space? Docker is using too much!**

A: Docker images, containers, and volumes can accumulate over time. Use these commands to clean up:

- `docker system prune` - Remove stopped containers, unused networks, and dangling images
- `docker system prune -a` - Also remove unused images (not just dangling)
- `docker volume prune` - Remove unused volumes

Be careful! This will delete data. Make sure you don't have volumes with important data before running prune commands.

**Q: Can I run multiple versions of the same software at once?**

A: Absolutely! This is one of Docker's superpowers. You can run `postgres:14`, `postgres:15`, and `postgres:16` all at the same time‚Äîjust use different container names and different host ports:

```bash
docker run -d --name pg14 -p 5432:5432 postgres:14
docker run -d --name pg15 -p 5433:5432 postgres:15
docker run -d --name pg16 -p 5434:5432 postgres:16
```

Now you have three PostgreSQL versions running simultaneously, accessible on ports 5432, 5433, and 5434!

## Take the Next Step

Now that you're comfortable running containers, here's what to practice:

1. **Experiment with different images** from Docker Hub
2. **Try creating volumes** for persistent data
3. **Use bind mounts** to see real-time file changes
4. **Run multiple containers** at once
5. **Practice the essential commands** until they feel natural

**Challenge:** Try running a Redis container and connecting to it with a Redis client. Can you figure out the right command from the [Redis Docker Hub page](https://hub.docker.com/_/redis)?

---

**Continue Learning:**

- Part 1: [Understanding Docker: A Beginner's Guide to Containers](./docker-introduction-history.md)
- Part 3: [Building Your Own Docker Images](#) (Coming soon!)

**Watch the Full Course:** [Complete Docker Course - From BEGINNER to PRO! (Learn Containers)](https://www.youtube.com/watch?v=RqTEHSBrYFw)

**Timestamp for this article:** 40:30 - 1:13:00

Have questions about Docker installation or running containers? Drop a comment below!