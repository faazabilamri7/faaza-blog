---
title: '# How to Build a Smart SQL Agent That Writes Queries for You (Step-by-Step Guide)'
category: general
tags:
  - general
  - auto-post
description: "## Introduction: Talking to Your Database in Plain English\n\nImagine asking your database a question in everyday language—like \"Show me the top 5 bes..."
pubDate: '2025-10-09T04:58:59.426Z'
draft: false
excerpt: "## Introduction: Talking to Your Database in Plain English\n\nImagine asking your database a question in everyday language—like \"Show me the top 5 bes..."
---

## Introduction: Talking to Your Database in Plain English

Imagine asking your database a question in everyday language—like "Show me the top 5 best-selling products this month"—and getting an instant answer without writing a single line of SQL code. Sounds like magic, right?

That's exactly what an **SQL Agent** does. It's like having a smart assistant that understands what you're asking, translates it into proper database language (SQL), checks its own work for mistakes, and even fixes errors automatically if something goes wrong.

In this guide, we'll walk through building your own SQL Agent from scratch. Don't worry if you're new to this—we'll break everything down into simple, digestible steps. By the end, you'll understand how these intelligent systems work and how they can save you hours of manual database querying.

Let's dive in!

---

## What Exactly Is an SQL Agent?

Think of an SQL Agent as a translator and problem-solver rolled into one.

When you type a question like "Which customers made purchases last week?", here's what the agent does behind the scenes:

1. **Understands your question** – It figures out what you're really asking
2. **Looks at your database structure** – It checks what tables and columns exist
3. **Writes the SQL query** – It generates the actual database command
4. **Double-checks for mistakes** – It validates the query before running it
5. **Runs the query** – It executes the command against your database
6. **Fixes errors automatically** – If something breaks, it tries again with corrections
7. **Gives you a readable answer** – It presents results in plain language

The beauty of this system? **It learns from its mistakes and keeps trying until it gets things right.**

---

## Why Do We Need an SQL Agent?

You might be wondering: "Can't I just write SQL queries myself?"

Sure, you can! But here's why an SQL Agent is incredibly valuable:

- **Saves time**: No more hunting through documentation to remember exact table names or column structures
- **Reduces errors**: The agent validates queries before running them, catching common mistakes
- **Self-correcting**: When errors happen, it automatically tries to fix them instead of giving up
- **Accessible to non-technical users**: Your marketing team can query data without bothering the tech team
- **Consistent**: It follows best practices every time, like limiting results and avoiding dangerous operations

Think of it like having GPS navigation versus reading a paper map. Both get you there, but one makes the journey much smoother.

---

## The Architecture: How Our SQL Agent Works

Before we build anything, let's understand the big picture. Our SQL Agent follows a **circular workflow** with built-in error handling:

```
User Question → Get Database Info → Generate Query → Check Query 
→ Run Query → Verify Results → Return Answer
```

But here's where it gets smart: **If anything goes wrong at any step, the agent loops back and tries again with corrections.** It's like having a persistent helper who doesn't give up easily.

The system has **two feedback loops**:

1. **Syntax Loop**: If the generated query has syntax errors, regenerate it
2. **Runtime Loop**: If the query fails during execution, fix it and retry

Now let's build this step by step!

---

## Step 1: Setting Up the Starting Point

Every journey needs a beginning. In our SQL Agent, we start with a **Start Node**—the entry point where users ask their questions.

### What We're Doing:
We're creating a place for users to type their questions in plain English and initializing a storage space to keep track of the SQL query as it develops.

### Configuration Details:
- **Input Type**: Set to "Chat Input" so users can ask questions naturally
- **Flow State**: Create a variable called `sqlQuery` with an empty value

**Why this matters:** The flow state is like a notebook where the agent jots down important information (like the SQL query being built) so it can reference it throughout the process.

**Simple analogy:** Think of this as opening a new document in Word—you need a blank canvas before you can start writing.

---

## Step 2: Getting to Know Your Database

Before the agent can write queries, it needs to understand your database structure—like getting a map before starting a road trip.

### What We're Doing:
We're connecting to the database and retrieving all the important information: table names, column types, and even sample data from each table.

### The Technical Setup:
We use a **Custom Function** node with JavaScript code that:

- Connects to your PostgreSQL database (you'll need to provide your credentials)
- Lists all tables in your database
- For each table, gets the column names and data types
- Fetches 3 sample rows to show what kind of data exists
- Formats everything into a readable description

### Example of What Gets Retrieved:

```
CREATE TABLE customers (id INTEGER NOT NULL, name TEXT, email TEXT)
SELECT * FROM customers LIMIT 3
id name email
1 John Doe john@example.com
2 Jane Smith jane@example.com
3 Bob Wilson bob@example.com
```

**Why this matters:** The agent needs this context to write accurate queries. Without it, the agent would be like a chef trying to cook without knowing what ingredients are available.

**Important note:** You'll need to update the connection details (HOST, USER, PASSWORD, DATABASE, PORT) to match your actual database. The example uses localhost with test credentials.

---

## Step 3: Generating the SQL Query

Now comes the exciting part—transforming human language into database language!

### What We're Doing:
We're using an **LLM (Large Language Model)** node—essentially an AI brain—to convert the user's question into a proper SQL query.

### The Prompt Strategy:
We give the AI specific instructions:

- "You are an agent designed to interact with a SQL database"
- "Create syntactically correct queries"
- "Limit results to 5 unless specified otherwise"
- "Only ask for relevant columns, not everything"
- "NEVER make destructive changes (no DELETE, UPDATE, DROP)"

We also feed it the database schema information we collected in Step 2.

### Structured Output:
To keep things clean, we force the AI to return results in a structured format (JSON) with a single field called `sql_query`. This prevents the AI from adding extra commentary.

**Example transformation:**
- User asks: "Show me the 5 most recent orders"
- AI generates: `SELECT * FROM orders ORDER BY order_date DESC LIMIT 5`

**Why structured output matters:** Without it, the AI might say something like "Sure! Here's your query: SELECT..." and we'd have to parse out the actual query from the explanation. Structured output gives us clean, predictable results.

The generated query is automatically saved to our flow state (`sqlQuery`) for use in later steps.

---

## Step 4: Validating the Query (First Safety Check)

Even smart AI can make mistakes. This step is like having a code reviewer double-check the work before it goes live.

### What We're Doing:
We're using a **Condition Agent** (another AI, but specialized for validation) to inspect the generated SQL query for common errors.

### What Gets Checked:
The validator looks for typical SQL mistakes:

- **NULL handling issues**: Using `NOT IN` with NULL values (this breaks in SQL)
- **UNION vs UNION ALL**: Using the wrong one affects performance and results
- **BETWEEN logic errors**: Using BETWEEN for ranges that should be exclusive
- **Data type mismatches**: Comparing numbers to text incorrectly
- **Quote problems**: Forgetting quotes around identifiers
- **Function argument errors**: Calling functions with wrong number of parameters
- **Type casting issues**: Converting data types incorrectly
- **Join column mistakes**: Joining tables on wrong columns

### The Decision:
The validator outputs one of two scenarios:
1. **Query is correct** → Proceed to execution
2. **Query has mistakes** → Loop back and regenerate

**Real-world example:** Imagine the AI generated:
```sql
SELECT * FROM users WHERE age NOT IN (NULL, 25, 30)
```

The validator would catch this because `NOT IN` with NULL always returns false in SQL—a subtle bug that's easy to miss!

---

## Step 5: The Retry Loop (When Validation Fails)

If the query has errors, we don't just give up. This is where the agent shows its intelligence.

### What We're Doing:
We're adding a **Loop Node** that sends the process back to the query generation step when validation fails.

### Configuration:
- **Loop Back To**: "Generate SQL Query" (Step 3)
- **Max Loop Count**: 5 attempts

### How It Works:
1. Query fails validation
2. Loop triggers, sending us back to the LLM
3. The LLM generates a new query (learning from context)
4. We validate again
5. Repeat up to 5 times if needed

**Why 5 attempts?** This prevents infinite loops. If the agent can't get it right after 5 tries, something is fundamentally wrong (maybe the question is impossible to answer with the available data).

**Analogy:** It's like taking a practice test, getting feedback on your mistakes, and trying again—but with a limit so you don't spend forever on one problem.

---

## Step 6: Running the Query (Moment of Truth)

The query passed validation! Now let's actually execute it against the database.

### What We're Doing:
We're using another **Custom Function** node to connect to the database and run the validated SQL query.

### The Execution Process:

1. **Receive the query** from flow state
2. **Connect to the database** using the same credentials from Step 2
3. **Execute the query** and capture results
4. **Format the output** into a readable structure
5. **Handle errors gracefully** if execution fails

### Output Format:
The function returns results like this:

```
SELECT name, email FROM customers LIMIT 3
name email
John Doe john@example.com
Jane Smith jane@example.com
Bob Wilson bob@example.com
```

Or if something goes wrong:
```
[Error executing query]: column "namee" does not exist
```

**Safety note:** Even though we validated the query, runtime errors can still happen (table might be locked, connection might drop, etc.). That's why we need error handling here.

**Technical detail:** We're using TypeORM's DataSource to manage database connections properly—this ensures connections are opened and closed correctly without leaking resources.

---

## Step 7: Checking If the Query Actually Worked

Just because the query ran doesn't mean it succeeded. This step verifies the results make sense.

### What We're Doing:
We're using another **Condition Agent** to analyze the query results and determine if they're valid or contain errors.

### What Gets Checked:
- Did the query return an error message?
- Are the results empty when they shouldn't be?
- Does the output format look correct?
- Are there any database error codes present?

### The Decision Tree:
1. **Results are good** → Generate a natural language response for the user
2. **Results have errors** → Regenerate the query with error context

**Example of catching problems:**

Even if the query runs, you might get:
```
[Error executing query]: syntax error near "FROM"
```

The Condition Agent spots this and triggers the regeneration loop.

---

## Step 8: Generating the Final Answer (Success Path)

When everything works perfectly, we need to present results in a user-friendly way.

### What We're Doing:
We're using a final **LLM Node** to transform the raw query results into natural, conversational language.

### The Transformation:

**Input** (raw results):
```
SELECT product_name, SUM(quantity) as total FROM sales GROUP BY product_name ORDER BY total DESC LIMIT 5
product_name total
Widget A 245
Widget B 198
Widget C 167
Widget D 143
Widget E 128
```

**Output** (user-friendly):
```
Based on your data, here are the top 5 best-selling products:

1. Widget A with 245 units sold
2. Widget B with 198 units sold
3. Widget C with 167 units sold
4. Widget D with 143 units sold
5. Widget E with 128 units sold

Widget A is clearly your best performer!
```

**Why this matters:** Most users don't want to read raw SQL output. They want insights and answers in plain English. This final step makes the agent truly conversational.

---

## Step 9: Smart Error Recovery (The Self-Correction Loop)

When the query runs but produces an error, the agent doesn't just report failure—it learns and tries again.

### What We're Doing:
We're adding an **LLM Node** that analyzes runtime errors and generates corrected queries.

### The Prompt:
```
Given the generated SQL Query: [original query]
I have the following error: [error message]
Regenerate a new SQL Query that will fix the error
```

### Example Recovery:

**Original Query:**
```sql
SELECT * FROM order WHERE customer_id = 5
```

**Error:**
```
table "order" does not exist
```

**Corrected Query:**
```sql
SELECT * FROM orders WHERE customer_id = 5
```

The agent recognized that "order" should be "orders" (plural).

**How it learns:** The LLM uses the error message as feedback to understand what went wrong and adjusts accordingly. It's similar to how humans debug code—read the error, understand the problem, fix it.

This regenerated query updates the flow state and proceeds to the next step.

---

## Step 10: The Second Loop (Runtime Error Recovery)

Just like we created a loop for validation errors, we need one for runtime errors.

### What We're Doing:
Adding a **Loop Node** connected to the query regeneration step.

### Configuration:
- **Loop Back To**: "Check SQL Query" (Step 4)
- **Max Loop Count**: 5 attempts

### The Complete Error Recovery Flow:
1. Query executes but produces an error
2. Error is analyzed and query is regenerated
3. Loop sends us back to validation
4. Regenerated query is checked for syntax
5. If valid, it's executed again
6. Repeat up to 5 times if needed

**Why loop back to validation?** Because the regenerated query might introduce new syntax errors while fixing the runtime error. Better to catch those before trying to execute again.

**Critical insight:** This creates a **nested loop system**:
- Outer loop: Runtime error recovery (checks execution results)
- Inner loop: Syntax error recovery (checks query structure)

Both loops work together to maximize success rate.

---

## The Complete System Flow: How Everything Connects

Let's visualize the entire agent workflow:

### Main Path (When Everything Works):
1. **User asks question** → Start Node
2. **Get database schema** → Custom Function
3. **Generate SQL query** → LLM with structured output
4. **Validate syntax** → Condition Agent
5. **Execute query** → Custom Function
6. **Verify results** → Condition Agent
7. **Return natural language answer** → Final LLM

### Error Recovery Paths:

**Path A: Syntax Errors**
- Validation fails → Loop back to Step 3 → Try again (max 5 times)

**Path B: Runtime Errors**
- Execution fails → Analyze error → Regenerate query → Loop back to Step 4 → Try again (max 5 times)

### Maximum Attempts:
- **Syntax validation**: 5 attempts
- **Runtime execution**: 5 attempts  
- **Total possible iterations**: Up to 25 query attempts (5 × 5) in worst case

**Real-world performance:** In practice, most queries succeed on the first or second attempt. The multiple loops are safety nets for edge cases.

---

## Testing Your SQL Agent: Real Examples

Now that you've built the agent, let's see it in action with different types of questions.

### Simple Query:
**User:** "Show me all customers"

**Generated SQL:**
```sql
SELECT * FROM customers LIMIT 5
```

**Response:** "Here are 5 customers from your database: [formatted list]"

---

### Analytical Query:
**User:** "What's the average order value by month this year?"

**Generated SQL:**
```sql
SELECT 
  DATE_TRUNC('month', order_date) as month,
  AVG(total_amount) as avg_value
FROM orders
WHERE EXTRACT(YEAR FROM order_date) = EXTRACT(YEAR FROM CURRENT_DATE)
GROUP BY month
ORDER BY month DESC
LIMIT 5
```

**Response:** "Here's your monthly average order value: January: $156.32, February: $143.87..."

---

### Complex Query with Error Recovery:
**User:** "Show me top 5 products by revenue"

**First Attempt** (has error):
```sql
SELECT product_name, SUM(price) as revenue
FROM sale
GROUP BY product_name
ORDER BY revenue DESC
LIMIT 5
```

**Error:** "table 'sale' does not exist"

**Second Attempt** (corrected):
```sql
SELECT product_name, SUM(price * quantity) as revenue
FROM sales
GROUP BY product_name
ORDER BY revenue DESC
LIMIT 5
```

**Success!** The agent automatically fixed both the table name (sale → sales) and the revenue calculation (price → price * quantity).

---

## Best Practices and Tips

### Security Considerations:

**✅ DO:**
- Store database credentials in environment variables
- Use read-only database users for the agent
- Implement rate limiting on queries
- Log all executed queries for auditing

**❌ DON'T:**
- Hardcode passwords in your code
- Give the agent DELETE or UPDATE permissions
- Allow unlimited query attempts (always set max loops)
- Expose sensitive data without filtering

---

### Optimization Tips:

1. **Cache database schema**: Don't fetch it every time—update only when schema changes
2. **Set result limits**: Always add LIMIT clauses to prevent overwhelming responses
3. **Use connection pooling**: Reuse database connections instead of creating new ones
4. **Add timeout limits**: Don't let queries run forever

---

### Common Pitfalls to Avoid:

**Problem**: Agent keeps looping infinitely  
**Solution**: Always set max loop counts (recommended: 5)

**Problem**: Queries run but return no useful data  
**Solution**: Include sample data in schema description so AI understands data patterns

**Problem**: Agent generates correct SQL but in wrong database dialect  
**Solution**: Specify exact database type (PostgreSQL, MySQL, etc.) in prompts

**Problem**: Security vulnerabilities from SQL injection  
**Solution**: Use parameterized queries and validate inputs before execution

---

## Key Takeaways: What You've Learned

Let's recap the important concepts:

### The Core Components:
1. **Schema retrieval**: Understanding database structure
2. **Natural language processing**: Converting questions to SQL
3. **Validation layers**: Catching errors before execution
4. **Self-correction loops**: Automatically fixing mistakes
5. **Human-friendly responses**: Presenting results conversationally

### The Intelligence Factor:
The agent doesn't just execute commands—it:
- Understands context from database schema
- Validates its own work
- Learns from errors
- Tries multiple approaches
- Explains results clearly

### The Business Value:
- **Time savings**: Minutes instead of hours for complex queries
- **Accessibility**: Non-technical users can query databases
- **Reliability**: Built-in error checking and recovery
- **Scalability**: Handles increasing query complexity

### The Technical Achievement:
You've built a system that combines:
- Database connectivity (TypeORM)
- AI language models (LLM nodes)
- Conditional logic (Condition Agents)
- Error handling (Loop nodes)
- State management (Flow state)

---

## Frequently Asked Questions

**Q: Do I need to be a programmer to build this?**

**A:** While basic programming knowledge helps (especially understanding JavaScript and SQL), the tutorial provides all the code you need. The main requirement is understanding the concepts and following the step-by-step configuration. Many no-code platforms now offer visual interfaces for building these agents.

---

**Q: What if my database uses MySQL instead of PostgreSQL?**

**A:** The core concepts remain the same! You'll need to:
- Change the `type` parameter in DataSource to 'mysql'
- Adjust the schema query syntax (MySQL uses different system tables)
- Update connection parameters if needed

The agent architecture works with any SQL database—just modify the connection details and schema queries.

---

**Q: How accurate is the SQL generation? Will it make dangerous mistakes?**

**A:** The system has multiple safety layers:
- Instructions explicitly prohibit destructive operations (DELETE, DROP, etc.)
- Validation catches syntax errors before execution
- You can use read-only database credentials to prevent modifications
- Max loop limits prevent runaway queries

That said, always test in a non-production environment first and review generated queries during initial deployment.

---

## Ready to Try It Yourself?

Now that you understand how SQL Agents work, here's your next step:

### Immediate Action:
1. Download the complete flow template ([SQL Agent.json](https://823733684-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2F00tYLwhz5RyR7fJEhrWy%2Fuploads%2Fz5Vm0jllYUXj6YzdeSa3%2FSQL%20Agent.json?alt=media&token=afbca6a6-860a-4103-be1c-cdbc5160ac28))
2. Update the database credentials with your test database
3. Start with simple queries to verify it works
4. Gradually test more complex scenarios

### Learn More:
Want to dive deeper into building AI agents? Check out the original tutorial for visual diagrams and additional implementation details:

**📚 Full Tutorial**: [SQL Agent Documentation](https://docs.flowise.ai/)

### Share Your Experience:
Have you built an SQL Agent? Encountered interesting challenges? Found creative use cases? Drop a comment below—we'd love to hear about your journey and help troubleshoot any issues!

---

**Remember**: The best way to learn is by doing. Start simple, experiment freely, and don't be afraid to make mistakes—that's exactly what your agent is designed to handle!

Happy building! 🚀