---
// PersonalizedRecommendations.astro - Display personalized content recommendations
import { getRecommendedPosts } from '~/utils/blog';
import type { Post } from '~/types';

interface Props {
  currentPost?: Post;
  maxRecommendations?: number;
  title?: string;
}

const { currentPost, maxRecommendations = 4, title = 'Recommended for You' } = Astro.props;

// Get recommendations based on user behavior (client-side enhancement)
const fallbackRecommendations = await getRecommendedPosts(maxRecommendations);
---

<div class="personalized-recommendations my-8">
  <div class="recommendations-header mb-6">
    <h2 class="text-2xl font-bold text-gray-900 dark:text-white mb-2">{title}</h2>
    <div class="flex items-center space-x-4 text-sm text-gray-600 dark:text-gray-400">
      <span id="engagement-score" class="flex items-center">
        <svg class="w-4 h-4 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 7h8m0 0v8m0-8l-8 8-4-4-6 6"></path>
        </svg>
        Engagement: <span class="font-medium">Calculating...</span>
      </span>
      <span id="recommendation-basis" class="text-xs">
        Based on your reading history
      </span>
    </div>
  </div>

  <div id="recommendations-grid" class="grid grid-cols-1 md:grid-cols-2 gap-6">
    <!-- Recommendations will be populated by JavaScript -->
  </div>

  <div id="loading-recommendations" class="text-center py-8">
    <div class="inline-block animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600"></div>
    <p class="mt-2 text-gray-600 dark:text-gray-400">Loading personalized recommendations...</p>
  </div>
</div>

<script>
  class PersonalizedRecommendations {
    private static recommendationsGrid: HTMLElement;
    private static loadingElement: HTMLElement;
    private static engagementScoreElement: HTMLElement;
    private static fallbackPosts: any[] = [];

    static async init() {
      this.recommendationsGrid = document.getElementById('recommendations-grid')!;
      this.loadingElement = document.getElementById('loading-recommendations')!;
      this.engagementScoreElement = document.getElementById('engagement-score')!;

      // Get fallback posts from server
      this.fallbackPosts = await this.getFallbackPosts();

      this.loadRecommendations();
      this.updateEngagementScore();
    }

    private static async loadRecommendations() {
      try {
        const userBehavior = (window as any).RecommendationEngine?.getUserBehavior() || {};
        const recommendedCategories = (window as any).RecommendationEngine?.getRecommendedCategories(3) || [];
        const recommendedTags = (window as any).RecommendationEngine?.getRecommendedTags(5) || [];

        // If user has behavior data, fetch personalized recommendations
        if (recommendedCategories.length > 0 || recommendedTags.length > 0) {
          const recommendations = await this.fetchPersonalizedRecommendations(
            recommendedCategories,
            recommendedTags
          );

          if (recommendations.length > 0) {
            this.renderRecommendations(recommendations);
            return;
          }
        }

        // Fallback to default recommendations
        this.renderRecommendations(this.fallbackPosts);
      } catch (error) {
        console.error('Error loading recommendations:', error);
        this.renderRecommendations(this.fallbackPosts);
      } finally {
        this.loadingElement.style.display = 'none';
      }
    }

    private static async fetchPersonalizedRecommendations(categories: string[], tags: string[]): Promise<any[]> {
      try {
        // In a real implementation, this would make an API call to get personalized recommendations
        // For now, we'll simulate this by filtering the fallback posts
        const filteredPosts = this.fallbackPosts.filter(post => {
          if (!post.category && !post.tags) return false;

          // Check category match
          const categoryMatch = categories.some(cat =>
            post.category?.slug === cat
          );

          // Check tag match
          const tagMatch = tags.some(tag =>
            post.tags?.some((postTag: any) => postTag.slug === tag)
          );

          return categoryMatch || tagMatch;
        });

        // If we have matches, return them; otherwise return recent posts
        return filteredPosts.length > 0 ? filteredPosts : this.fallbackPosts.slice(0, 4);
      } catch (error) {
        console.error('Error fetching personalized recommendations:', error);
        return this.fallbackPosts;
      }
    }

    private static async getFallbackPosts(): Promise<any[]> {
      // This would normally come from the server, but for now we'll return empty array
      // The actual posts are passed from the server-side rendering
      return [];
    }

    private static renderRecommendations(posts: any[]) {
      if (!posts || posts.length === 0) {
        this.recommendationsGrid.innerHTML = `
          <div class="col-span-full text-center py-8">
            <svg class="w-12 h-12 mx-auto mb-4 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"></path>
            </svg>
            <p class="text-gray-600 dark:text-gray-400">No recommendations available</p>
          </div>
        `;
        return;
      }

      const recommendationsHtml = posts.map(post => `
        <article class="recommendation-card bg-white dark:bg-gray-800 rounded-lg shadow-sm border border-gray-200 dark:border-gray-700 overflow-hidden hover:shadow-md transition-shadow duration-200">
          ${post.image ? `
            <div class="aspect-video overflow-hidden">
              <img
                src="${post.image}"
                alt="${post.title}"
                class="w-full h-full object-cover hover:scale-105 transition-transform duration-200"
                loading="lazy"
              />
            </div>
          ` : ''}
          <div class="p-4">
            <h3 class="font-semibold text-gray-900 dark:text-white mb-2 line-clamp-2 hover:text-blue-600 dark:hover:text-blue-400 transition-colors duration-200">
              <a href="/post/${post.slug}" class="block">${post.title}</a>
            </h3>
            <p class="text-sm text-gray-600 dark:text-gray-400 mb-3 line-clamp-3">
              ${post.excerpt || post.description || ''}
            </p>
            <div class="flex items-center justify-between text-xs text-gray-500 dark:text-gray-400">
              <span>${this.formatDate(post.publishDate)}</span>
              ${post.readingTime ? `<span>${post.readingTime} min read</span>` : ''}
            </div>
            ${post.tags && post.tags.length > 0 ? `
              <div class="mt-3 flex flex-wrap gap-1">
                ${post.tags.slice(0, 3).map((tag: any) => `
                  <span class="inline-block px-2 py-1 text-xs bg-gray-100 dark:bg-gray-700 text-gray-700 dark:text-gray-300 rounded">
                    ${tag.title}
                  </span>
                `).join('')}
              </div>
            ` : ''}
          </div>
        </article>
      `).join('');

      this.recommendationsGrid.innerHTML = recommendationsHtml;
    }

    private static updateEngagementScore() {
      const score = (window as any).RecommendationEngine?.getEngagementScore() || 0;
      const scoreElement = this.engagementScoreElement.querySelector('.font-medium') as HTMLElement;

      if (scoreElement) {
        scoreElement.textContent = score.toString();

        // Add engagement level indicator
        let level = 'Beginner';
        if (score > 50) level = 'Engaged';
        if (score > 100) level = 'Expert';
        if (score > 200) level = 'Power User';

        scoreElement.innerHTML += ` <span class="text-xs text-gray-500">(${level})</span>`;
      }
    }

    private static formatDate(dateString: string): string {
      const date = new Date(dateString);
      const now = new Date();
      const diffTime = Math.abs(now.getTime() - date.getTime());
      const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

      if (diffDays === 1) return 'Today';
      if (diffDays === 2) return 'Yesterday';
      if (diffDays < 7) return `${diffDays} days ago`;
      if (diffDays < 30) return `${Math.ceil(diffDays / 7)} weeks ago`;
      return date.toLocaleDateString();
    }
  }

  // Initialize on page load
  document.addEventListener('DOMContentLoaded', () => {
    PersonalizedRecommendations.init();
  });
</script>

<style>
  .line-clamp-2 {
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
    overflow: hidden;
  }

  .line-clamp-3 {
    display: -webkit-box;
    -webkit-line-clamp: 3;
    -webkit-box-orient: vertical;
    overflow: hidden;
  }
</style>